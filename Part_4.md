# Задание 4
### Тест-дизайн
**Тест-дизайн** процесс разработки техник и методов тестирования. Представляет собой продумывание и написание тестовых случаев (test case), в соответствии с требованиями проекта, критериями качества будущего продукта и финальными целями тестирования.  
**Цели:** придумать тесты, которые найдут наиболее критические ошибки. Минимизировать количество тестов сохранив тестовое покрытие.  
**Этапы:**
- изучить требования к продукту
- оценить возможные риски
- написать достаточный минимум тестов
- разграничить тесты на приемочные, критические, расширенные.  
**План:**  
1) Анализ контекста и задач
2) Декомпозиция (процесс разбиения задачи на более мелкие)
3) Комбинаторика, Применение техник-тест дизайна
4) Проектирование и создание тест-кейсов 
5) Тестовое покрытие - одна из метрик оценки качества тестирования, представляющая из себя плотность покрытия тестами требований либо исполняемого кода.  
Существуют следующие подходы к оценке тестового покрытия:  
- **Покрытие требований** - оценка покрытия тестами функциональных и нефункциональных требований к продукту путем построения матриц трассировки (traceability matrix);
- **Покрытие кода** - оценка покрытия исполняемого кода тестами, путем отслеживания непроверенных в процессе тестирования частей программного обеспечения.  
**Тестовое покрытие на базе анализа потока управления** - оценка покрытия, основанная на определении путей выполнения кода программного модуля и создания выполняемых тест-кейсов для покрытия этих путей.  
### 2. Техники тест-дизайна
**Техники тест-дизайна** - это правила и подходы, которые помогают создавать грамотные тест-кейсы для проведения тестирования приложения.  
**Техники метода черного ящика**  
1) Эквивалентное разделение (Equivalence Partitioning - EP).
2) Анализ граничных значений (Boundary Value Analysis - BVA).
3) Предугадывание ошибки (Error Guessing - EG).
4) Исчерпывающее тестирование (Exhaustive Testing - ET).
5) Причина/Следствие (Cause/Effect-CE)
6) Таблица принятия решений (Decision table).
7) Тестирование состояний и переходов (State - transition testing).
8) Метод парного тестирования (Pairwise testing)  
### 3. Эквивалентное разбиение (Equivalence Partitioning - EP)
**Эквивалентное разбиение** - тестирование методом черного ящика, в котором тестовые условия представлены эквивалентными областями, проверяемыми на одном представителе каждой области (ISTQB)  
Суть техники эквивалентного разбиения в том, чтобы:
- Разделить данные на группы (классы эквивалентности), которые, как предполагается, обрабатываются системой схожим образом (то есть ведут систему к одному состоянию);
- Из каждой группы (класса) выбрать одно значение и проверить его.  

**Класс эквивалентности (Equivalence class)** – это набор входных (или выходных) данных, которые обрабатываются программой по одному алгоритму или приводят к одному результату.  
Если все работает правильно, мы считаем, что для всех других эквивалентных значений все будет работать правильно. И наоборот.  
Пошаговый процесс эквивалентного разбиения:
- Определить классы эквивалентности. Это главный шаг техники. От него во многом  зависит эффективность её применения.
- Затем нужно выбрать одного представителя от каждого класса. На этом шаге из каждого эквивалентного набора тестов мы выбираем один тест.
- Нужно выполнить тесты. На этом шаге мы выполняем тесты от каждого класса эквивалентности.
### 4. Анализ граничных значений (Boundary Value Analysis)  
**Граничные значения** — это те места, в которых один класс эквивалентности переходит в другой.  
**Цель этой техники** — найти ошибки, связанные с граничными значениями. На каждой границе диапазона следует проверить по три значения:
- граничное значение;
- значение перед границей;
- значение после границы.  

Все классы эквивалентности делятся на три типа:
1) Класс, который имеет нижнюю и верхнюю границы (Класс 1)
2) Класс, который имеет только нижнюю границу (Класс 3)
3) Класс, который имеет только верхнюю границу (Класс 2)  
Существует два варианта определения граничных значений - это 2 boundary value analysis (2 BVA) и 3 boundary value analysis (3 BVA).  
При анализе граничных значения методом 2 BVA мы берем одно значение внутри класса и одно ближайшее значение вне класса.  
При анализе граничных значения методом 3 BVA мы берем два значение внутри класса и одно ближайшее значение вне класса.  

### 5. Предугадывание ошибки (Error Guessing - EG).  
Метод проектирования тестов, когда опыт тестировщика используется для предугадывания того, какие дефекты могут быть в тестируемом компоненте или системе в результате сделанных ошибок, а также для разработки тестов специально для их выявления.  
- Интуиция и опыт
- Знание типов типичных ошибок
- Анализ прошлых дефектов
- Погружение в систему  
В данной методике нет какого-либо специфического метода идентификации ошибок. Тестировщик действует, исходя из своего опыта и интуиции, чтобы заранее определить уязвимые места в тестируемом продукте. Поэтому успешность этой методики сильно зависит от опыта, навыков и глубины понимания тестируемого продукта.

### 6. Исчерпывающее тестирование (Exhaustive Testing - ET)
это метод тестирования, при котором проверяются все возможные комбинации входных данных и сценариев использования приложения.  
Исчерпывающее тестирование имеет следующие преимущества:
- Тесты могут быть автоматизированы, что избавит от необходимости проводить работу вручную.
- Проверяет все возможные варианты данных в наборе.
- Делает программу более надежной, выявляя любые возможные ошибки.
- Выполняет повторное тестирование задач с высоким приоритетом.
- Повышает удовлетворенность клиентов от продукта.

### 7. Причина/Следствие (Cause/Effect-CE)
Этот метод используется в тестировании для определения комбинаций условий (причин), которые могут привести к определенному результату (следствию) в системе.  
Например, если нажать крестик в правом верхнем углу окна (причина), оно закроется (следствие), и т.д.  
1. Выделяем причины и следствия в спецификациях.  
2. Связываем причины и следствия.  
3. Учитываем «невозможные» сочетания причин и следствий.  
4. Составляем «таблицу решений», где в каждом столбце указана комбинация входов и выходов, т.е. каждый столбец – это готовый тестовый сценарий.  
5. Расставляем приоритеты.

### 8. Таблица принятия решений (Decision table).
Тестирование таблицы решений — это метод тестирования программного обеспечения, используемый для проверки поведения системы при различных комбинациях входных данных.   
Более простыми словами, таблица решений состоит из условий (в заголовках строк и колонок), и действий (в точках пересечения условий).  
Как составлять таблицу
- По горизонтали — выписываем условия, которые влияют на результат. А чуть ниже — сам результат, в оригинале Action — действие, которое нужно выполнить.
- По вертикали — правила: конкретная комбинация входных условий.

### 9. Тестирование состояний и переходов (State - transition testing)
Тестирование состояний и переходов (или перехода состояний) изучает, как система переходит из одного состояния в другое в ответ на события.
Подобные диаграммы дают нам четкое и структурированное представление о том, как ведет себя наша программа в ответ на различные входные сигналы. 
 
### 10. Комбинаторные техники.
1. Попарное (Pairwise) тестирование
2.  Базовый выбор 
3.  Каждый выбор 
4.  Ортогональные матрицы

### 11. Метод парного тестирования (Pairwise testing)
**Попарное тестирование** - техника тест-дизайна методом черного ящика, при которой тест-кейсы создаются таким образом, чтобы выполнить все возможные отдельные комбинации каждой пары входных параметров.  
Метод попарного тестирования базируется на гипотезе, что подавляющее большинство дефектов ПО возникает, когда взаимодействуют два входных параметра. Следовательно, надо проверить не все возможные комбинации параметров, а только такой набор комбинаций, в котором каждая пара параметров встретится хотя бы раз. 

### 12. Каждый выбор
эта стратегия требует, чтобы каждое значение каждого параметра было включено по крайней мере в один тестовый пример.  

### 13. Базовый выбор
Мы выбираем "базовые" значения для каждой переменной. Обычно выбираются самые часто используемые или наиболее типичные значения.  
**Техника базового выбора (Base Choice)** — одна из комбинаторных техник тест-дизайна, которая ориентирована на выбор базового набора тестовых значений для каждой переменной, а затем создание тестовых случаев путем изменения только одной переменной за раз, оставляя остальные на базовом уровне.

### 14. Тестирование с помощью ортогональных массивов (Orthogonal array testing, OAT)  
Lee Copeland в своей книге A Practitioner's Guide to Software Test Design говорит о том, что для создания тест-кейсов для попарного тестирования можно использовать две техники - алгоритм All pairs и ортогональные массивы.  
**Ортогональный массив (ортогональная таблица)** - это таблица, обладающая следующими свойствами:  
- Любые два столбца таблицы содержат все комбинации значений этих столбцов.
- Если какая-либо пара значений двух столбцов встречается несколько раз, то все возможные парные комбинации значений этих столбцов должны встретиться столько же раз.  
Например, L18(2137) – смешанный ортогональный массив с восемнадцатью строками, у которого один столбец со значениями 1 и 2, и семь столбцов со значениями 1, 2, 3.  
Строят ортогональный массив, который имеет столбец для каждой переменной.   Каким образом это можно сделать?  
- руками
- используя библиотеки готовых ортогональных таблиц.  

### 15. Методики тест-дизайна методом Белого ящика
**Разработка тестов методом белого ящика (white-box test design technique):** Процедура разработки или выбора тестовых сценариев на основании анализа внутренней структуры компонента или системы. (ISTQB)  
Глобально основных техник динамического тестирования методом белого ящика всего две:
- Тестирование потока управления (Control Flow Testing);
- Тестирование потока данных (Data Flow Testing).  
Основные методы тестирования белого ящика включают:
- Покрытие операторов (statement coverage) 
- Покрытие решений (decision coverage) 
- Покрытие условий (condition coverage)  
**Оператор** — это любая отдельная команда в программе, которая выполняет определенное действие. Это может быть присвоение значения переменной, ввод/вывод данных, вызов функции и так далее.  
**Покрытие операторов:** означает, что мы пишем тесты таким образом, чтобы каждый оператор в программе был выполнен хотя бы один раз.  
Покрытие операторов позволяет найти:
- Неиспользованные выражения (Unused Statements);
- Мертвый код (Dead Code);
- Неиспользуемые ветви (Unused Branches);
- Недостающие операторы (Missing Statements);  
Для определения того, сколько тестов потребуется, чтобы обеспечить 100% покрытие операторов нужно найти минимальное количество кратчайших путей, которое покроет все узлы блок-схемы.  
Инструменты для покрытия операторов:
- Cobertura (для Java) — анализатор покрытия кода, который помогает измерять покрытие операторов и условий.
- JaCoCo (для Java) — популярный инструмент для анализа покрытия кода, который поддерживает покрытие операторов, ветвей и условий. (JUnit используется для написания и выполнения тестов, а JaCoCo — для анализа покрытия кода)
- Coverage.py (для Python) — инструмент для измерения покрытия кода в Python, поддерживает покрытие операторов и других метрик.  
**Решения** — это логические конструкции, которые выбирают один из нескольких возможных путей выполнения программы в зависимости от условий. Наиболее распространенными примерами решений являются операторы if, else if и else, а также switch-выражения.  
**Покрытие решений:** это тестирование программы таким образом, чтобы каждая ветвь решения была выполнена хотя бы один раз. Другими словами, нужно протестировать и истинную ветвь (например, P > 100), и ложную (например, P <= 100).  
**Условия** —  это логическое выражение, которое возвращает либо true (истина), либо false (ложь). Условия используются в решениях для определения, какой путь выполнения программы выбрать.  
**Тестирование покрытия условий** — это тип тестирования «белого ящика», который проверяет все условные выражения в программе для всех возможных результатов условий. Его также называют покрытием предикатов.  
Оно гарантирует, что тестирование включает выполнение обеих ветвей в решении, как оператор if. Если точка принятия решения имеет разные условия (используя AND или OR), покрытие условий гарантирует, что мы протестировали все различные комбинации условий.  
**Блок-схема** - это способ описания алгоритма, при котором он изображается геометрическими фигурами (блоками), связанными по управлению линиями (направлениями потока) со стрелками. В блоках записывается последовательность действий.  
**Граф-схема** обычно представляет собой граф, где узлы соответствуют различным блокам кода или контрольным точкам, а рёбра между узлами показывают потоки управления между этими блоками.  
**Покрытие операторов**: малое количество тестов, поверхностная проверка и высокие риски ошибок   
**Покрытие решений/альтернатив**: умеренное кол-во тестов, средняя глубина и средние риски.  
**Покрытие условий**: Большее кол-во тестов, глубокая проверка и низкие риски.  
**Тестирование на основе потока данных (Data Flow Testing)** — это техника тест-дизайна, которая фокусируется на пути данных через программу и использовании переменных в различных точках кода.  
**Цель этого метода** — проверить правильность и целостность работы с данными (переменными) в программе, от их инициализации до использования и завершения.  
**Цель тестирования потока данных:**  
Основная цель — убедиться, что переменные используются корректно на всех этапах, чтобы избежать типичных ошибок, таких как:  
- Использование неинициализированной переменной.
- Избыточное присваивание значения переменной, которое затем не используется.
- Использование переменной после её завершения.
