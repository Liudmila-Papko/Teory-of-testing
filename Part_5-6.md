# Задание 5-6

### 1. Тест-план
**Тест-план** — это артефакт тестирования, который описывает стратегию тестирования, цели, подходы и ресурсы для тестирования ПО. В нем обычно подробно расписывают задачи, которые нужно выполнить, и методы, которые будут использовать. Также указывают ресурсы и сроки этого проекта.  
Тест план имеет четкую структуру, установленную **IEEE 829** (Ай-Трипл-И)  
**Как написать план тестирования:**  
Хороший тест план должен как минимум отвечать на следующие вопросы:
- что надо тестировать (объект тестирования: система, приложение, оборудование)
- что будете тестировать (список функций и компонент тестируемой системы) и что не будете тестировать
- как будете тестировать (стратегия тестирования - виды тестирования и их применение по отношению к тестируемому объекту)
- когда будете тестировать (последовательность проведения работ: подготовка, тестирование, анализ результатов, в разрезе запланированных фаз разработки проекта)
- критерии начала тестирования (к таким критериям можно отнести готовность тестовой платформы (тестового стенда), законченность разработки требуемого функционала, наличие всей необходимой документации)
- критерии окончания тестирования
(когда результаты тестирования удовлетворяют критериям качества продукта:
  - требования к количеству открытых багов выполнены
  - выдержан определенный период без изменения исходного кода приложения Code Freeze (CF)
  - выдержан определенный период без открытия новых багов Zero Bug Bounce (ZBB)  
Далее, Тест-план нужно дополнить следующими пунктами:
- Окружение тестируемой системы (версии ОС, браузеров)
- Необходимые для тестирования ресурсы 
  - программные ресурсы - инструменты для тестирования (например, Jira, TestRail, Selenium)
  - аппаратные ресурсы
  - человеческие ресурсы
  - временные ресурсы
  - финансовые ресурсы
  - тестовые данные
- Риски и их разрешение.  
Чтобы создать этот документ в соответствии с требованиями стандарта IEEE 829, необходимо выполнить следующие шаги:  
1) Проанализировать продукт
2) Разработать стратегию тестирования
3) Определить цели тестирования
4) Определить критерии тестирования
5) Запланировать ресурсы
6) Настроить тестовую среду
7) Распределить задачи
8) Определить результаты тестирования  
**Виды тест планов**
- **Мастер тест план** (project test plan or Master Test Plan)  
Тест план (Test Plan), или детальный тест план
План приемочных испытаний (Product Acceptance Plan) — документ, описывающий набор действий, связанных с приемочным тестированием (стратегия, дата проведения, ответственные работники и т.д.)
Мастер Тест-План (Master Test Plan): “Главный план тестирования (master test plan, project test plan): План тестирования, обычно охватывающий несколько уровней тестирования.” (ISTQB). Это может быть как единственный базовый план, так и главный в иерархии нескольких планов, самый статичный и высокоуровневый.  
Нужен когда:
- продукт имеет множество релизов или итераций, между которыми сохраняется общая информация, которую нет смысла повторять;
- разные тестовые команды работают над одним продуктом, выполняя различные задачи, которые необходимо объединить в рамках одного документа;  
В виде RACI-матрицы.  
RACI помогает избежать ситуаций, когда непонятно, кто принимает решения, кто выполняет работу, кто несет ответственность. Чаще всего матрица представляет собой табличку, где по вертикали расположены задачи, а по горизонтали – фамилии конкретных людей. На пересечении — то, какие роли они выполняют в проекте.  
- (responsible (ответственный за работу) — тот, кто непосредственно выполняет задание;
- accountable (ответственный за результат) — тот, кто принимает работу и несёт ответственность за результат;
- consulted (консультирующий) — тот, кто оказывает консультативную помощь;
- informed (информируемый) — тот, кто в курсе принимаемых решений и хода выполнения задачи.  

**Детальный Тест-план (Phase Test plan):** Уровневый план тестирования (level test plan):  
Детальный план составляется на каждый релиз/итерацию или для каждой команды в рамках проекта и является динамическим, т.е. может претерпевать изменения по необходимости.  
Его основная цель - кратко и доходчиво отразить задачи тестирования. Детальных планов может быть несколько для отдельных модулей ПО или команд тестирования. Кроме того, могут быть созданы планы для отдельных уровней тестирования (Level Test Plan) или видов тестирования. В Agile проектах могут быть планы итерационного тестирования (iteration testing plans) для каждой итерации;  

**План приемочных испытаний (Acceptance Test Plan, ПСИ):** план приемочного тестирования отличают от обычного плана тестирования факторы, которые приводят к принятию бизнес-решения. План приемочного тестирования - это один из жизненно важных документов, который содержит руководство по выполнению приемочного тестирования для конкретного проекта. Пишется на основе бизнес-требований (Business Requirements).  
Пример тест-плана:
- в виде документа, 
- в виде таблицы и т.д. 

### 2. Чек-лист

**Чек-лист в тестировании** - это список проверок, которые необходимо провести для тестирования приложения или его части.  
Для того чтобы чек-лист был действительно полезным инструментом, он должен обладать рядом важных свойств:
- Логичность
- Последовательность и структурированность
- Полнота и неизбыточность.  
Можно выделить две разновидности чек-листов: специальные и универсальные. Специальные создаются для конкретного проекта, проверки отражают его специфику. Универсальные подходят для тестирования проектов одного типа, проверки в них не привязываются к графическим элементам или конкретной реализации.  
**Обязательные части чек-листа**  
- Шапка:  
  - название  приложения, 
  - его версия, 
  - окружение (версия ОС, браузера, эмулятора),
  - ответственный за тестирование
  - дата тестирования 
- Тестируемые модули, субмодули: например, регистрация, аутентификация авторизация
- Список проверок: они должны отражать основную суть, без лишней детализации (Title)
- Статус: информация о статусе прохождения проверки:
  - Passed (Пройден) — проверка прошла успешно. Используется, когда тест полностью соответствует ожидаемым результатам.
  - Failed (Провален) — проверка провалилась. Это значит, что обнаружены несоответствия между фактическим результатом и ожидаемым.
  - Blocked (Заблокирован) — тест не может быть выполнен из-за каких-то внешних причин. Например, недостаток данных, сбои в системе или зависимость от другой задачи, которая не завершена.
  - Skipped (Пропущен) — тест был намеренно пропущен. Может быть, проверка нерелевантна для текущей версии, задачи или её выполнение не требуется.
  - Not Run (Не выполнен) — тест ещё не был выполнен. Этот статус ставится до того, как проверка началась.
  - N/A (Not Applicable, не применимо) означает, что проверка или тест не относится к текущему контексту, сценарию или продукту.  
**Дополнительные части чек-листа**  
- Ожидаемый результат:  то, что мы ожидаем увидеть после запуска проверки согласно требованиям
- Типы тестирования: к какому типу относится проверка?
- Отчеты о дефекте: ссылки на отчеты о дефектах для прослеживаемости
- Заметки: если нужно добавить комментарии  
Также у проверок может быть уникальный идентификатор для прослеживаемости.

### 3. Тест-кейс
**Тест-кейс** - это документ, разработанный с целью проверки того или иного  свойства или  поведения системы или продукта,в котором есть: 
- входные данные
- условия выполнения
- ожидаемые результаты.  
**Виды тест-кейсов:**
- **позитивный тест-кейс** проверяет отсутствие сообщений об ошибке там, где это не предусмотрено, и исполнение системой позитивного сценария нормального использования ПО.
- **негативный тест-кейс** определяет поведение системы при получении некорректных входных данных. В этом случае система не проигрывает позитивный сценарий, то есть не делает того, что не предусмотрено.
- **деструктивный тест-кейс** - проверяет систему на прочность. С его помощью тестировщики изучают сценарии работы ПО в экстремальных условиях, например при повышенной нагрузке, при попытках взломать страницу или внедрить сторонние скрипты в формы регистрации.

**Основные атрибуты тест-кейса:**
- **Идентификатор (ID)** - уникальная нумерация тест-кейса в виде сочетания цифр и букв.
- **Заголовок (Summary или Description)**. Краткое описание идеи и сути тест-кейса.
- **Входные данные (Inputs).**  Указывается информация об исходном состоянии системы.
- **Пошаговые мероприятия (Steps)**. Это последовательные пункты, описывающие действия тестировщика.
- **Ожидаемый результат (Expected Results).** Описание того, что тестировщик ожидает получить по окончании или в процессе тестирования. 
- **Фактический результат (Actual Results):** Описание того, что тестировщик получил по факту (если необходимо).
- **Статус.** Атрибут отражает нынешнее состояние кейса
«Failed». «Blocked». «Skipped». «In progress», Pass  
Еще могут быть пре-кондишн, ID bug  
Cвойства тест-кейса являются показателями их качества:
1) грамотный технический язык, 
2) чёткость используемых формулировок
3) последовательное и понятное изложение, отсутствие «пробелов» в информации
4) использование только безличных глаголов (например, «войти» вместо «войдите»)
5) конкретика, детальность всех стадий 
6) правильное указание названий, наименований в тексте.  
Существуют 6 правил проведения тест кейсов:
- Один тест кейс должен проверять только одну конкретную вещь.
- Тест кейс не должен зависеть от других тест кейсов.
- Шаги и ожидаемый результат тест кейса должны быть сформулированы четко и однозначно.
- В тест кейсе должна быть вся информация. необходимая для его проведения.
- В тест кейсе не должно быть лишних деталей.
- Для каждого шага тест кейса нужно указывать тип вводимых данных: валидный или невалидный.

### 4. Тестовый набор
**Тестовый набор (test siute)** - это набор тестов/тест-кейсов, собранных по функциональности в последовательность для достижения некоторой цели.  
Характеристики тестового набора:
- Создается на основе тест-плана
- Описывает цели тест-кейсов
- В тестовый набор входят параметры тестируемого приложения, настройки окружения, и подобные вспомогательные файлы и настройки
- Тестовые наборы могут быть как функциональной, так и нефункциональной направленности
- Тестовые наборы ускоряют и облегчают процесс тестирования
- Тест-кейсы в сьюте выполняются последовательно, и выполнение следующего зависит от предыдущего
- Могут автоматизироваться, например в Selenium.  
Чаще всего формируют стандартные «дымовые» и регрессионные тестовые наборы. При необходимости добавляя/удаляя оттуда тест-кейсы.

### 5. БАГ-репорт
**Баг-репорт (bug report)** — это технический документ, который подробно описывает ошибку в работе программы, приложения или другого ПО. 
Его составляют, чтобы разработчикам было понятно, что работает неправильно, насколько дефект критичен и что нужно исправить.

По версии (ISTQB), **баг (дефект)** — изъян в компоненте или системе, который может привести компонент или систему к невозможности выполнить требуемую функцию.  
**Как правильно оформить баг-репорт:**  
- Воспроизводится ли баг.
- Нет ли уже такого бага-репорта в системе. Если баг уже есть, следует обновить его описание.
- Максимально точно локализовать баг.
- Если баг не найден — начинаем оформление. Не стоит забывать важное правило: один дефект — один баг в трекере.

**Атрибуты Баг репорта**, как правило, следующие:
- **ID** -порядковый номер
- **Environment** - окружение, на котором найден баг
- **Severity (Серьезность)** - атрибут, характеризующий влияние дефекта на работоспособность приложения. Проставляется тестировщиком или техническим специалистом, который может оценить степень влияния дефекта на работу системы.
- **Priority (Приоритет)** - атрибут, указывающий на очередность выполнения задачи или устранения дефекта. Проставляется руководителем или менеджером проекта.
- **Summary/Title (Тайтл, описание)** - раздел, который кратко передает суть бага одним предложением.
- **Precondition (Предварительное условие)** - используется, если предварительно систему нужно приводить к состоянию, пригодному для проведения проверки
- **Steps (Шаги для воспроизведения)** - последовательность действий для воспроизведения бага. 
- **Expected result (Ожидаемый результат)** - описание того, как программа или функциональность должны работать.
- **Actual result (Фактический результат)** -  описание того, что происходит на самом деле. 
- **Attachment (Вложения)** - файл с логами, скриншот/видео или любой другой документ, который может помочь прояснить причину ошибки или указать на способ решения проблемы.
- **Author (Автор)** - создатель баг-репорта
- **Assigned To (Назначен на)** - имя сотрудника, назначенного на решение проблемы.

**Summary/Title: Что? Где? Когда?**  
Необходимо составить предложение, в котором факты дефекта изложены в следующей последовательности:
- Где?: В каком месте интерфейса пользователя или архитектуры программного продукта находится проблема. Причем, начинайте предложение с существительного, а не предлога.
- Что?: Что происходит или не происходит согласно спецификации или вашему представлению о нормальной работе программного продукта. При этом указывайте на наличие или отсутствие объекта проблемы, а не на его содержание (его указывают в описании). Если содержание проблемы варьируется, все известные варианты указываются в описании.
- Когда? (При каких обстоятельствах?): В какой момент работы программного продукта, по наступлению какого события или при каких условиях проблема проявляется.

### 6. Жизненный цикл бага 
**Жизненный цикл бага (bug workflow)** – последовательность этапов, которые проходит баг на своем пути с момента его создания до окончательного закрытия.  
**Цель жизненного цикла бага** – в координации работы с багом и легкой передаче его текущего статуса различным ответственным лицам.
Назначение багам статуса позволяет лучше отслеживать фактический прогресс их жизненного цикла.  
- **Новый (New).** Тестировщик нашел баг, дефект успешно занесен в «Bug-tracking» систему.
- **Открыт — Закрыт** (1) По разным причинам дефект может и не считаться дефектом или считаться неактуальным.  Иногда этот переход выносят в отдельный этап жизненного цикла, который называется Отклонен (Rejected). 
- **Открыт — В Работе** (2) Баг подтвержден и передан разработчикам, которые начали работу над исправлением.
- **В Работе — Закрыт** (3) Бывает, что в ходе исправления бага разработчик понимает, что это не баг, а что-то другое (фича / неточность в требованиях, которую обсудили без тестировщиков и т.п.) В этом случае разработчик описывает почему это не баг и закрывает задачу.
- **В Работе — Исправлен** (4) Ошибку локализовали и исправили, она передана тестировщику.
- **Исправлен — Открыт** (5) Тестировщик проверил исправление, баг все еще воспроизводится, то есть не исправлен. Он возвращается разработчику (возможно с указанием каких-то дополнительных деталей). Этот переход может существовать как отдельный этап жизненного цикла бага — Переоткрыт (Reopened).
- **Исправлен — Закрыт** (6) Тестировщик проверил исправление, баг больше не воспроизводится.
- **Закрыт — Открыт** (7) Если баг случайно закрыли, должна быть возможность его переоткрыть. Не стоит переоткрывать закрытые баги, если они уже были исправлены, проверены и закрыты. Ситуация может возникать в ходе регрессионного тестирования.

**Резолюция** – это решение принятое по дефекту.  
Решено(Fixed), Дубликат(Duplicate), Отложено(Deferred), Отклонено (Rejected), Не ошибка(Not a Bug).

### 7. Severity (Серьезность)
**Severity (Серьезность)** - это атрибут, характеризующий влияние бага на общую функциональность тестируемого продукта.  
**Классификация серьезности(Severity):**
- **Blocker(Блокирующий);** Это самый высокий уровень серьезности. Блокирующий баг делает приложение или его критические функции полностью недоступными. Такие баги требуют немедленного внимания.
Пользователи не могут войти в свои аккаунты на платформе Capital.com. При вводе правильных данных для входа (логин и пароль), система либо выдает сообщение об ошибке, либо бесконечно загружает страницу.
- **Critical(Критический);** Критические баги серьезно нарушают работу приложения, хотя его части могут оставаться доступными. 
Пример: При попытке перевести деньги с одного счета на другой в интернет-банке происходит сбой системы, и деньги списываются с отправителя, но не поступают на счёт получателя.
- **Major(Серьезный);** Серьезные баги влияют на основные функции приложения, но их последствия не столь катастрофичны, как у критических багов.  
Графики цен на активы (например, акции, валюты) отображают некорректные данные: время обновления задерживается, и текущие цены на активы не соответствуют фактическим рыночным значениям. Пользователи могут торговать, но видят устаревшие или неправильные цены на графиках.
- **Minor(Незначительный);** Незначительные баги затрагивают второстепенные функции или вызывают проблемы, которые не сильно мешают работе пользователя.  
Не переведена кнопка с английского на арабский.
- **Trivial(Тривиальный).** Это наименее серьезные баги, которые практически не влияют на функциональность программы и вызывают лишь небольшие неудобства. Обычно это косметические дефекты или мелкие проблемы с интерфейсом.  
Опечатка в тексте, не загружена иконка флага возле названия языка.

### 8. Приоритет (priority)
**Приоритет (priority)** - характеристика, которая показывает необходимость скорейшего устранение дефекта. Чем выше приоритет, тем быстрее нужно приступить к работе по исправлению.
- **P1 Наивысший (Critical)** (ASAP, as soon as possible) 
Ошибка должна быть исправлена настолько быстро, насколько это возможно и может варьироваться от «в ближайшем билде» до единиц минут.
- **P2 Высокий (High)** 
Ошибка должна быть исправлена как можно быстрее, т.к. ее наличие является критической для проекта.
- **P3 Средний (Medium)** 
Ошибка должна быть исправлена, ее наличие не является критичной, но требует обязательного решения.
- **P4 Низкий (Low)**  
Ошибка должна быть исправлена, ее наличие не является критичной, и не требует срочного решения.

**Примеры:**  
**Высокий приоритет (Priority) и низкая серьезность (Severity)**  
Кнопки перекрывают друг друга. Они кликабельны, но визуальное впечатление портится.  
Логотип компании на главной странице содержит орфографическую ошибку. На функционал это вообще не влияет, но портит пользовательский опыт. Этот баг нужно исправить с высоким приоритетом, несмотря не то, что на продукт он влияет минимально.  
**Высокая серьезность (Severity) и низкий приоритет (Priority)**  
1) Домашняя страница сайта ужасно выглядит в старых браузерах. Перекрывается текст, не загружается логотип. Это мешает пользоваться продуктом, поэтому серьезность бага высокая. Но так как очень мало пользователей открывают сайт при помощи устаревшего браузера, такой баг получает низкий приоритет.  
2) Допустим, у нас есть приложение для банкинга. Оно правильно рассчитывает ежедневный, ежемесячный и ежеквартальный отчет, но при расчете годового возникают проблемы. Этот баг имеет высокую степень серьезности. Но если сейчас формирование годовой отчетности не актуально, такой дефект имеет низкий приоритет: его можно исправить в следующем релизе.  
3)Невозможность попасть на страницу комментариев к товару. 
В этом процессе произошел сбой в свойствах системы; однако, поскольку этот сбой не относится к основному потоку, его целесообразно классифицировать на этом уровне.

### 9. Матрица соответствия требований (Requirements Traceability Matrix)
**Трассируемость (traceability):** Способность идентифицировать связанные объекты в документации и программном обеспечении. Например, требования со связанными с ними тестами. (ISTQB)  
**Матрица трассируемости (traceability matrix):** двумерная таблица, описывающая связь двух сущностей (например, требований и тестовых сценариев). Таблица позволяет производить прямую и обратную трассировку от одной сущности к другой, обеспечивая таким образом возможность определения покрытия и оценки влияния предполагаемых изменений. (ISTQB)  
Матрица трассируемости может служить одновременно в качестве матрицы покрытия. Наличие такой матрицы позволяет объективно оценить, какая часть продукта покрыта тестами, а какая нет.  
**Типы матриц**
**Прямая прослеживаемость:** Сопоставляет требования с соответствующими проектными документами, кодом и тестовыми случаями. Это помогает гарантировать, что все требования реализованы.  
**Обратная прослеживаемость:** Связывает результаты и тестовые случаи с их исходными требованиями, гарантируя, что ничего не было добавлено без обоснования или что дополнительные функции не были включены непреднамеренно.  
**Двунаправленная отслеживаемость:** Обеспечивает как прямую, так и обратную прослеживаемость, предлагая комплексное представление связей между требованиями, результатами проекта и тестовыми случаями. Этот тип RTM обеспечивает полное покрытие, отслеживая требования от начала до конца и наоборот.  

**Компоненты RTM-матрицы (могут варьироваться)** 
- ID требования
- Тип и описание требования
- ID тест-кейса
- Статус тест-кейса

### 10. Тест-отчет
**Отчет о тестировании (Test report)** – вид тестовой документации, который обобщает опыт проведенных QA-мероприятий. Он может быть разных типов, от этого зависит его содержание. Отчет о тестировании служит для принятия соответствующих решений в IT-проекте.  
**Отчет (Report)** - это документ, содержащий информацию о выполненных действиях, результатах проведённой работы. Обычно он включает в себя таблицы, графики, списки, просто описывающую информацию в виде текста. Их пропорция и содержание определяют пользу и понятность отчета.  
Отчеты по тестированию программного обеспечения классифицируют по времени:
- Недельный, месячный, промежуточный. В подобных отчетах тестировщик указывает две основные метрики: уровень готовности, оценку проведенного тестирования; В общем, это практически тот же финальный отчет, но с измененными приоритетами фокуса и уменьшенной глубиной временной выборки. 
- Версионный. Похож на финальный отчет. Здесь указывают, какие задачи выполнялись командой, работающей над проектом. Делается в конце работы над каждой версией приложения;
- Финальный, или заключительный. Прописывается эволюция продукта, описывается общий взгляд на сделанную работу. Также, надо дать исчерпывающую информацию о статусе продукта в данный момент (количество оставшихся неисправленных ошибок, полностью ли протестирован продукт или требуется дополнительный цикл тестирования, оценка возможности выпуска продукта во «внешний мир» и т.д).  
**По типу**:
- Промежуточный (Progress-report)  
Промежуточный отчет составляется и отправляется на всех заинтересованных лиц после проведения каждого вида тестов. Данный тип отчета составляет инженер по тестированию, проверивший заданную часть функциональности. 
- Итоговый (Final report)  
В конце предопределенного промежутка времени (обычно за неделю либо перед выходом очередной сборки) составляется итоговый отчет о всей проделанной работе. В отчете отражена информация о качестве всех проведенных видов тестов. Как правило, такой отчёт составляет ведущий тестировщик либо руководитель QA-команды. Он анализирует всю информацию о состоянии ПО и собирает её воедино.  
**Структура отчета**  
- Команда тестировщиков
- Описание процесса тестирования 
- Краткое описание 
- Расписание 
- Рекомендации
- Статистика новых ошибок 
- Статистика по всем ошибкам   
**Ошибка (ISTQB)** — любое действие человека, которое вызвало неверный результат. Ошибки могут быть допущены разработчиками, тестировщиками или пользователями.  
**Дефект (баг)** — изъян в компоненте или системе, который может привести компонент или систему к невозможности выполнить требуемую функцию (ISTQB). Это несоответствие между ожидаемым результатом и фактическим поведением системы.  
**Отказ ( ISTQB)** – событие, при котором система не выполняет ожидаемую функцию. Это постоянное нарушение работы системы, которое делает её непригодной для использования. Отказы могут быть вызваны серьезными дефектами или ошибками, которые не были обнаружены и исправлены.  
**Сбой** — это временное нарушение работы системы, которое может привести к неправильному результату или поведению.  
Сбои могут быть вызваны внешними факторами, такими как отключение электроэнергии или ошибка пользователя.  
Следовательно, разработчик может допустить ошибку, написав некорректный код. При работе функций приложения эта ошибка становится дефектом, который должен найти тестировщик. Дефект может вызвать сбой или отказ.

### 11. Основные типы багов:
- Воспроизводимый — баг, который может быть воспроизведен тестировщиком в тестовом окружении.
- Невоспроизводимый — баг, который не может быть воспроизведен тестировщиком в тестовом окружении.
- Фатальный — баг, который вызывает крах или аварийное завершение программы.
- Не фатальный — баг, который не вызывает крах программы, но может приводить к некорректному поведению или неправильным результатам.
- Функциональный  — баг, связанный с неправильной работой функциональности программы.
- Нефункциональный — баг, связанный с аспектами производительности, надежности, безопасности и т.д. программы.
- Интерфейсный — баг, связанный с интерфейсом пользователя.
- Синтаксический — баг, связанный с нарушением правил синтаксиса языка программирования.
- Логический — баг, связанный с неправильной логикой работы программы.
- Спецификационный — баг, связанный с нарушением требований к программе, указанных в спецификации.
- Визуальный — баг, связанный с отображением графических элементов программы.
- Локализационный — баг, связанный с неправильным отображением или переводом программы на другие языки.
- Неоднозначный — баг, который может иметь несколько причин и неоднозначный результат.
- Потенциальный — баг, который еще не проявился, но может возникнуть в будущем при определенных условиях.
- Дублирующий — баг, который уже был зарегистрирован и описан ранее.

### 12. Что такое хитрые баги?
**Хитрые баги** — это скрытые дефекты, которые трудно обнаружить из-за специфических условий их возникновения. Они могут проявляться нерегулярно, в зависимости от конфигурации системы, загрузки или временных факторов.  
**Гейзенбаг** — это баг, который исчезает или меняет свое поведение, как только его пытаются изучить или отладить.  
**Борбаг** — это баг, который проявляется постоянно, но только при определенных условиях или входных данных.  
**Мандельбаг** — это баг с чрезвычайно сложным и непредсказуемым поведением, часто вызванный глубокими архитектурными дефектами системы.  
**Шрединбаг** — это баг, который проявляется только при определённых условиях и может исчезнуть при попытке изучения кода. Как и в парадоксе Шрёдингера, баг как бы «существует и не существует одновременно», пока его не начнут тестировать.  
**Лунный баг** — это баг, который проявляется только в определённое время, зависимо от даты или времени суток. Он может возникнуть из-за скрытых временных параметров в коде, что делает его сложным для обнаружения и воспроизведения.  
**Статистический баг** — это баг, который не проявляется при одном прогоне, но возникает при многократном выполнении кода, генерирующего случайные или псевдослучайные результаты.  
**Баг Хиггса** — это баг, существование которого предсказано или предполагается, но на практике его невозможно обнаружить. Он может существовать только «теоретически», из-за ошибки в логике кода, но никогда не проявляется при реальном использовании.  

### 13. Локализация бага
**Включает в себя** 
- наличие бага 
- выявление последствий бага, выяснение, как он проявляется, в чем выражается, взаимосвязей вызвавших ситуацию
- анализ, построение гипотез о корне проблемы и их отсеивание
- попытка воспроизведения бага.  
Где рождаются баги:
- Внутри нового кода
- На стыке нового и старого кода
- В старом коде впоследствии вызова из нового кода

### 14. Методы локализации дефектов в клиентской части
- **Тестирование на разных устройствах/браузерах:** Проверка работоспособности приложения в разных браузерах и на разных устройствах, так как дефекты могут быть специфичны для определенной платформы.
- **Инспектирование DOM:** Визуальный анализ структуры страницы через инспектор в браузере для поиска проблем с версткой, CSS и взаимодействиями элементов.
- **Отладка (Debugging):**
Вставка точек останова (breakpoints) в коде с использованием инструментов разработчика для поэтапного выполнения кода и анализа поведения приложения.  
Это помогает определить, где происходит сбой логики или что вызывает неправильное поведение интерфейса.
- **Тестирование UI вручную (Manual UI Testing):**  
Проверка элементов интерфейса на наличие визуальных или функциональных дефектов.
- **Использование разных браузеров, устройств и разрешений экрана** для выявления кроссбраузерных и кроссплатформенных проблем.
- **Логи браузера/консоль разработчика:** Проверка ошибок и предупреждений в консоли разработчика в браузере (F12). Это помогает выявить JavaScript ошибки, сетевые запросы, проблемы с загрузкой ресурсов и другие ошибки.  
**Логи** — это записи событий и сообщений, создаваемые программой или системой во время ее работы. Они представляют собой источник информации о том, что происходит внутри приложения в определённый момент времени.  
**Виды логов**
  - Логи приложения, логи сервера, системные логи.
- **Инструменты сетевого мониторинга:** Использование вкладки "Сеть" (Network) в консоли разработчика браузера для анализа сетевых запросов, ответа сервера, заголовков и статусов HTTP.  
- **Анализ производительности (Performance):** Изучение вкладки "Performance" для выявления проблем с производительностью клиентской части, таких как долгие загрузки или утечки памяти.  
- **Перезапуск с кешем и без кеша:** Очистка кеша и повторная загрузка страницы для исключения проблем, связанных с кешированием.  
**Кэш** — это память программы или устройства, которая сохраняет временные или часто используемые файлы для быстрого доступа к ним.  
**Есть два типа кэш-памяти:**
   - Аппаратная кэш-память — память системы. Свой кэш есть у жёсткого диска, графического ускорителя и процессора.
   - Программная кэш-память — это папки на диске устройства, в которых программы и сервисы сохраняют свои файлы для быстрого доступа.  
Кэш нужно чистить, чтобы увеличить скорость работы программ и предотвратить ошибки в них.  
- **Cookie (куки)** — это небольшие фрагменты данных, которые содержат информацию о пользователе и его действиях на сайте.
- **Эмуляция/симуляция мобильных устройств:** Использование инструментов эмуляции и симуляции для проверки отображения и работы на разных на мобильных устройствах.  
- **Fiddler/Charles Proxy:** Для перехвата и анализа сетевых запросов, когда нужно глубже проанализировать обмен данными между клиентом и сервером.

### 12. Методы локализации дефектов в серверной части
- **Анализ HTTP-ответов:** Проверка статусов HTTP-ответов, содержимого тела ответа и заголовков с помощью инструментов браузера или сетевых утилит. Это позволяет понять, есть ли ошибки со стороны сервера (например, 500 Internal Server Error).  
Вспомним уже приведенные выше примеры. Можно сказать, что тестирование через вкладку network в devtools в первую очередь помогает анализировать Frontend, а именно, как браузер взаимодействует с сервером. Основное внимание уделяется тому, как пользовательский интерфейс и браузер отправляют запросы и обрабатывают ответы от сервера.  
Там мы больше наблюдаем за тем, как frontend взаимодействует с backend, а не как сам backend функционирует.  
**Charles Proxy** используется больше для перехвата и анализа реальных запросов между клиентом и сервером (как в браузере, так и в мобильных приложениях), а также для модификации и мониторинга сетевого трафика.  

Поэтому для тестирование самой backend части и прямого тестирования API больше подойдут такие программы как Postman и SoupUI.  
- **Postman:** Использование инструментов для отправки API-запросов напрямую к серверу для проверки корректности обработки запросов и ответов без участия клиентской части.  
Отправка запроса методом GET для получения информации.  
Добавление пользователя в базу данных с помощью метода POST.  
Проверяем, что пользователь добавлен с помощью запроса к базе данных методом GET.  
- **Логи сервера:** Просмотр серверных логов, чтобы выявить ошибки или исключения, возникающие на сервере при выполнении запросов.  
Для этой задачи используют такие программы как:
    - Graylog
    - GoAccess
    - ELK Stack (Elasticsearch, Logstash, Kibana) и другие.  
- **Мониторинг серверных ресурсов:** Анализ нагрузки на сервер, доступности ресурсов (CPU, память, диск) с помощью мониторинговых систем, чтобы понять, не является ли дефект следствием нехватки ресурсов.  
Основные программы:
    - htop / top (Linux, macOS) – для мониторинга ресурсов в реальном времени.
    - Task Manager / Resource Monitor (Windows) – встроенные инструменты для просмотра использования CPU, памяти и сети.
    - Prometheus + Grafana – сбор и визуализация данных о состоянии сервера и его ресурсов.
    - Netdata – лёгкий и наглядный мониторинг ресурсов в реальном времени через веб-интерфейс.
    - Zabbix – для глубокого мониторинга IT-инфраструктуры с уведомлениями.
    - Nagios – для мониторинга серверов и сервисов с возможностью настройки плагинов.
    - New Relic – облачное решение для мониторинга серверов и приложений.
- **Дебаг на стороне сервера:** Совместная работа с разработчиками для использования отладочных инструментов сервера (например, отладка с помощью IDE или других инструментов логирования).
- **Анализ базы данных:** Проверка запросов к базе данных на правильность, выполнение и результаты с помощью инструментов мониторинга БД (например, SQL-запросы, используемые сервером).
- **Логирование запросов к базе данных:** Включение логов SQL-запросов (например, в MySQL можно включить slow query log) помогает выявить медленные запросы, ошибки при выполнении запросов, неправильное использование индексов и др.
- **Анализ производительности запросов (Query Profiling):** Инструменты профилирования запросов, такие как EXPLAIN в MySQL, позволяют анализировать, как база данных выполняет запросы. Это помогает понять, где возникают проблемы, такие как медленные JOIN-ы, отсутствие индексов или неправильное использование функций.
- **Мониторинг базы данных:** Инструменты мониторинга, такие как MySQL Workbench, Percona Monitoring and Management (PMM) или Grafana с подключением к базе, могут помочь отслеживать использование ресурсов базы данных (память, CPU, дисковые операции). Это помогает выявить потенциальные проблемы производительности.
- **Тестирование целостности данных:** Использование скриптов для проверки консистентности данных, чтобы убедиться, что данные не повреждены, отсутствуют или не искажены при операциях записи и чтения.
- **Тестирование кэширования:** Проверка корректности работы серверного кэширования, например, как сервер обрабатывает повторяющиеся запросы и обновляет данные.  
    - Redis и Memcached: Для серверного кэширования часто используются Redis и Memcached. Их нужно тестировать на корректную работу в плане производительности и хранения данных.
    - Varnish Cache: Может быть использован для кэширования HTTP-ответов, что особенно полезно для веб-приложений с высокой нагрузкой.  
**Примеры методов и подходов:**
1) **Валидация данных в кэше** - Проверка свежести данных. Убедится, что кэшированные данные актуальны и обновляются при изменении оригинальных данных в базе. Например, если пользователь изменил данные, кэш должен обновиться.
2) **Тестирование кэширования на уровне API** - Проверка кэширования HTTP-заголовков. Убедится, что сервер корректно использует HTTP-заголовки кэширования, такие как Cache-Control, ETag, Expires, чтобы клиенты могли повторно использовать кэшированные данные.
3) **Анализ возможных проблем с кэшем** - Проверить, что кэширование не дублируется на нескольких уровнях (например, кэш на уровне базы данных, на уровне приложения и HTTP), так как это может вызвать проблемы с синхронизацией данных.
